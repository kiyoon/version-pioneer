# üßóüèΩ Version-Pioneer: General-Purpose Versioneer without Boilerplate. 

## Background

[Versioneer](https://github.com/python-versioneer/python-versioneer) finds the closest git tag like `v1.2.3` and generates a version string like `1.2.3+4.gxxxxxxx.dirty`.

- `1.2.3` is the closest git tag.
- `+4` is the number of commits since the tag.
- `gxxxxxxx` is the git commit hash (without the leading `g`).
- `.dirty` is appended if the working directory is dirty (i.e. has uncommitted changes).

[setuptools-scm](https://github.com/pypa/setuptools-scm) is a similar tool, but with some differences:

- How the version string is rendered: `1.2.3+4.gxxxxxxx.dirty` vs `1.2.4.dev4+gxxxxxxx`
    - No `.dirty` in setuptools-scm.
    - Infer the next version number (i.e. 1.2.4 instead of 1.2.3).
- The `_version.py` file is always a constant in setuptools-scm.
    - Versioneer can dynamically generate the version string at runtime, so it's always up-to-date. Useful for development (pip install -e .).
    - Setuptools-scm won't ever change the version string after installation. You need to reinstall to update the version string.


## Why this fork?

I've used versioneer for years and I like the format and dynamic resolving version for development. But I have projects that are not using setuptools (like `hatch`, `poetry`, `maturin`, `scikit-build`, etc.), and even projects that are not Python (like Rust, Chrome Extension, etc.). Every time I had to figure out how to integrate a new VCS versioning plugin but they all work differently and produce different version strings. GitHub Actions and other tools may not work with all different version format. Different language usually expects different format, and it's especially hard to make it compatible for mixed language projects.

The original versioneer is 99% boilerplate code to make it work with all legacy setuptools configurations. But the core functionality is simple: just get version from git tag and format it. I needed to use this logic to integrate in every project I had.

**üßóüèΩ  Version-Pioneer is a general-purpose Versioneer that works with any language and any build system.**

- **Highly customisable**: It's a easy-to-read script. Customise how you format or resolve the version string.
- Runs with Python 3.7+, no dependencies.
- Works with any build backend with hooks.
- Works with any language, not just Python.
- Support for new version formats like `"digits"` that generates digits-only version string like `1.2.3.4`. Useful for multi-language projects, Chrome Extension, etc.


## Understanding Version-Pioneer

Before getting started, it's important to understand how Version-Pioneer works, so you can customise it to your needs. There is a `hatchling` plugin to make it easier to use in Python projects which will be described in the next section.

The core functionality is in one file.

Copy-paste [`src/version_pioneer/_version.py`](src/version_pioneer/_version.py) to your project (like `src/my_project/_version.py`). When you install like `pip install -e .`, this is used as is.

```python
# pseudo code of _version.py, original.
def get_versions(cfg = None):
    # Some logic to get the version string from git.
    # Read the source code. You can easily understand and customise it.
    ...

version_dict = get_versions()
__version__ = version_dict["version"]

if __name__ == "__main__":
    print(__version__)
```

`src/my_project/_version.py` when you install like `pip install .`.  
The original file is replaced with this. This is generated by literally executing the above file and saving version_dict as a constant.

```python
# pseudo code of _version.py, generated.
version_dict = {
    "version": "0.3.2+15.g2127fd3.dirty",
    "full-revisionid": "2127fd373d14ed5ded497fc18ac1c1b667f93a7d",
    "dirty": True,
    "error": None,
    "date": "2024-12-17T12:25:42+0900",
}
__version__ = version_dict["version"]

if __name__ == "__main__":
    print(__version__)
```

## üö¶ Usage

