# üßóüèΩ Version-Pioneer: General-Purpose Versioneer without Boilerplate. 

## Background

[Versioneer](https://github.com/python-versioneer/python-versioneer) finds the closest git tag like `v1.2.3` and generates a version string like `1.2.3+4.gxxxxxxx.dirty`.

- `1.2.3` is the closest git tag.
- `+4` is the number of commits since the tag.
- `gxxxxxxx` is the git commit hash (without the leading `g`).
- `.dirty` is appended if the working directory is dirty (i.e. has uncommitted changes).

[setuptools-scm](https://github.com/pypa/setuptools-scm) is a similar tool, but with some differences:

- How the version string is rendered: `1.2.3+4.gxxxxxxx.dirty` vs `1.2.4.dev4+gxxxxxxx`
    - No `.dirty` in setuptools-scm.
    - Infer the next version number (i.e. 1.2.4 instead of 1.2.3).
- The `_version.py` file is always a constant in setuptools-scm.
    - Versioneer can dynamically generate the version string at runtime, so it's always up-to-date. Useful for development (pip install -e .).
    - Setuptools-scm won't ever change the version string after installation. You need to reinstall to update the version string.


## ‚ùì Why this fork?

I've used versioneer for years and I like the format and dynamic resolving version for development. But,

1. It doesn't support any build backends other than `setuptools` (like `pdm`, `hatchling`, `poetry`, `maturin`, `scikit-build`, etc.)
2. It doesn't support projects that are not Python (like Rust, Chrome Extension, etc.).

Every time I had to figure out how to integrate a new VCS versioning plugin but they all work differently and produce different version strings. GitHub Actions and other tools may not work with all different version format. Different language usually expects different format, and it's especially hard to make it compatible for mixed language projects.

The original versioneer is 99% boilerplate code to make it work with all legacy setuptools configurations. But the core functionality is simple: just get version from git tag and format it. I had to leverage this logic to integrate Versioneer in every project I had.

**üßóüèΩ  Version-Pioneer is a general-purpose Versioneer that works with any language and any build system.**

- **Highly customisable**: It's a easy-to-read script. Customise how you format or resolve the version string.
- Runs with Python 3.7+, no dependencies.
- Works with any build backend with hooks.
- Works with any language, not just Python.
- Support for new version formats like `"digits"` that generates digits-only version string like `1.2.3.4`. Useful for multi-language projects, Chrome Extension, etc.


## üí° Understanding Version-Pioneer

Before getting started, it's important to understand how Version-Pioneer works, so you can customise it to your needs. There is a `hatchling` plugin to make it easier to use in Python projects which will be described in the next section.

The core functionality is in one file.

Copy-paste [`src/version_pioneer/_version.py`](src/version_pioneer/_version.py) to your project (like `src/my_project/_version.py`). When you install like `pip install -e .`, this is used as is.

```python
# pseudo code of _version.py, original.
def get_versions(cfg = None):
    # Some logic to get the version string from git.
    # Read the source code. You can easily understand and customise it.
    ...

version_dict = get_versions()
__version__ = version_dict["version"]

if __name__ == "__main__":
    import json

    print(json.dumps(__version_dict__))
```

`src/my_project/_version.py` when you install like `pip install .`.  
The original file is replaced with this. This is generated by literally executing the above file and saving version_dict as a constant.

```python
# pseudo code of _version.py, generated.
version_dict = {
    "version": "0.3.2+15.g2127fd3.dirty",
    "full-revisionid": "2127fd373d14ed5ded497fc18ac1c1b667f93a7d",
    "dirty": True,
    "error": None,
    "date": "2024-12-17T12:25:42+0900",
}
__version__ = version_dict["version"]

if __name__ == "__main__":
    import json

    print(json.dumps(__version_dict__))
```

### Configuring a Hatchling Hook

Even if you are not familiar with Hatchling, hear me out. It is very straightforward.

Add hatchling configuration to `pyproject.toml`.

```toml
[build-system]
requires = ["hatchling", "tomli ; python_version < '3.11'"]
build-backend = "hatchling.build"

[tool.hatch.version]
source = "code"
path = "src/my_project/_version.py"
expression = "__version__"  # default

[tool.hatch.build.hooks.custom]
path = "hatch_build.py"

[tool.version-pioneer]
versionfile-source = "src/my_project/_version.py"
versionfile-build = "my_project/_version.py"

[project]
name = "my-project"
dynamic = ["version"]
```

Basically you are telling Hatchling to execute `src/my_project/_version.py` and use `__version__` as the version string.

Add `hatch_build.py` to the project root.

```python
from __future__ import annotations

import stat
import sys
import tempfile
import textwrap
from os import PathLike
from pathlib import Path
from typing import Any

from hatchling.builders.hooks.plugin.interface import BuildHookInterface

if sys.version_info < (3, 11):
    import tomli as tomllib
else:
    import tomllib


def load_toml(file: str | PathLike) -> dict[str, Any]:
    with open(file, "rb") as f:
        return tomllib.load(f)


class CustomPioneerBuildHook(BuildHookInterface):
    def initialize(self, version: str, build_data: dict[str, Any]) -> None:
        if version == "editable":
            return

        pyproject_toml = load_toml(Path(self.root) / "pyproject.toml")

        # evaluate the original _version.py file to get the computed version
        versionfile_source = Path(
            pyproject_toml["tool"]["version-pioneer"]["versionfile-source"]
        )
        version_py = versionfile_source.read_text()
        module_globals = {}
        exec(version_py, module_globals)

        # replace the file with the constant version
        self.temp_version_file = tempfile.NamedTemporaryFile(mode="w", delete=True)  # noqa: SIM115
        self.temp_version_file.write(
            textwrap.dedent(f"""
                #!/usr/bin/env python3
                # This file is generated by version-pioneer
                # by evaluating the original _version.py file and storing the computed versions as a constant.

                __version_dict__ = {module_globals["__version_dict__"]}
                __version__ = __version_dict__["version"]
                
                if __name__ == "__main__":
                    import json

                    print(json.dumps(__version_dict__))
            """).strip()
        )
        self.temp_version_file.flush()

        # make it executable
        versionfile_build = Path(self.temp_version_file.name)
        versionfile_build.chmod(versionfile_build.stat().st_mode | stat.S_IEXEC)

        build_data["force_include"][self.temp_version_file.name] = Path(
            pyproject_toml["tool"]["version-pioneer"]["versionfile-build"]
        )

    def finalize(
        self,
        version: str,
        build_data: dict[str, Any],
        artifact_path: str,
    ) -> None:
        if version != "editable":
            # Delete the temporary version file
            self.temp_version_file.close()
```

It just replaces the `_version.py` file with a constant version string. The version string is computed by evaluating the original `_version.py` file.
This is skipped when the project is installed in editable mode (`pip install -e .`).

Now you can install your package with `pip install .`, `pip install -e .`, or build a wheel with `hatch build` or `uv build`.

### Configuring a PDM backend hook

The idea is the same, but the PDM doesn't really evaluate a code to get a version string (or maybe it doesn't work in this case).
So we do both in the hook.

üìÑ pyproject.toml:

```toml
requires = ["pdm-backend"]
build-backend = "pdm.backend"

[tool.pdm.build]
custom-hook = "pdm_build.py"

[tool.version-pioneer]
versionfile-source = "src/my_project/_version.py"
versionfile-build = "my_project/_version.py"

[project]
name = "my-project"
dynamic = ["version"]
```

üêç pdm_build.py:

```python
import stat
import textwrap
from pathlib import Path

from pdm.backend.hooks.base import Context


def pdm_build_initialize(context: Context):
    # Update metadata version
    versionfile_source = Path(
        context.config.data["tool"]["version-pioneer"]["versionfile-source"]
    )
    versionfile_code = versionfile_source.read_text()
    version_module_globals = {}
    exec(versionfile_code, version_module_globals)
    context.config.metadata["version"] = version_module_globals["__version__"]

    # Write the static version file
    if context.target != "editable":
        versionfile_build = context.build_dir / Path(
            context.config.data["tool"]["version-pioneer"]["versionfile-build"]
        )
        context.ensure_build_dir()
        versionfile_build.parent.mkdir(parents=True, exist_ok=True)
        versionfile_build.write_text(
            textwrap.dedent(f"""
                #!/usr/bin/env python3
                # This file is generated by version-pioneer
                # by evaluating the original _version.py file and storing the computed versions as a constant.

                __version_dict__ = {version_module_globals["__version_dict__"]}
                __version__ = __version_dict__["version"]

                if __name__ == "__main__":
                    import json

                    print(json.dumps(__version_dict__))
            """).strip()
        )
        # make it executable
        versionfile_build.chmod(versionfile_build.stat().st_mode | stat.S_IEXEC)
```

## üö¶ Usage

