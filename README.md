# ðŸ§—ðŸ½ Version-Pioneer: General-Purpose Versioneer without Boilerplate. 

## Background

[Versioneer](https://github.com/python-versioneer/python-versioneer) finds the closest git tag like `v1.2.3` and generates a version string like `1.2.3+4.gxxxxxxx.dirty`.

- `1.2.3` is the closest git tag.
- `+4` is the number of commits since the tag.
- `gxxxxxxx` is the git commit hash (without the leading `g`).
- `.dirty` is appended if the working directory is dirty (i.e. has uncommitted changes).

[setuptools-scm](https://github.com/pypa/setuptools-scm) is a similar tool, but with some differences:

- How the version string is rendered: `1.2.3+4.gxxxxxxx.dirty` vs `1.2.4.dev4+gxxxxxxx`
    - No `.dirty` in setuptools-scm.
    - Infer the next version number (i.e. 1.2.4 instead of 1.2.3).
- The `_version.py` file is always a constant in setuptools-scm.
    - Versioneer can dynamically generate the version string at runtime, so it's always up-to-date. Useful for development (pip install -e .).
    - Setuptools-scm won't ever change the version string after installation. You need to reinstall to update the version string.


## â“ Why this fork?

I've used versioneer for years and I like the format and dynamic resolving version for development. But I have projects that are not using setuptools (like `hatchling`, `poetry`, `maturin`, `scikit-build`, etc.), and even projects that are not Python (like Rust, Chrome Extension, etc.). Every time I had to figure out how to integrate a new VCS versioning plugin but they all work differently and produce different version strings. GitHub Actions and other tools may not work with all different version format. Different language usually expects different format, and it's especially hard to make it compatible for mixed language projects.

The original versioneer is 99% boilerplate code to make it work with all legacy setuptools configurations. But the core functionality is simple: just get version from git tag and format it. I needed to use this logic to integrate in every project I had.

**ðŸ§—ðŸ½  Version-Pioneer is a general-purpose Versioneer that works with any language and any build system.**

- **Highly customisable**: It's a easy-to-read script. Customise how you format or resolve the version string.
- Runs with Python 3.7+, no dependencies.
- Works with any build backend with hooks.
- Works with any language, not just Python.
- Support for new version formats like `"digits"` that generates digits-only version string like `1.2.3.4`. Useful for multi-language projects, Chrome Extension, etc.


## ðŸ’¡ Understanding Version-Pioneer

Before getting started, it's important to understand how Version-Pioneer works, so you can customise it to your needs. There is a `hatchling` plugin to make it easier to use in Python projects which will be described in the next section.

The core functionality is in one file.

Copy-paste [`src/version_pioneer/_version.py`](src/version_pioneer/_version.py) to your project (like `src/my_project/_version.py`). When you install like `pip install -e .`, this is used as is.

```python
# pseudo code of _version.py, original.
def get_versions(cfg = None):
    # Some logic to get the version string from git.
    # Read the source code. You can easily understand and customise it.
    ...

version_dict = get_versions()
__version__ = version_dict["version"]

if __name__ == "__main__":
    import json

    print(json.dumps(__version_dict__))
```

`src/my_project/_version.py` when you install like `pip install .`.  
The original file is replaced with this. This is generated by literally executing the above file and saving version_dict as a constant.

```python
# pseudo code of _version.py, generated.
version_dict = {
    "version": "0.3.2+15.g2127fd3.dirty",
    "full-revisionid": "2127fd373d14ed5ded497fc18ac1c1b667f93a7d",
    "dirty": True,
    "error": None,
    "date": "2024-12-17T12:25:42+0900",
}
__version__ = version_dict["version"]

if __name__ == "__main__":
    import json

    print(json.dumps(__version_dict__))
```

### Configuring a Hatchling Hook

Even if you are not familiar with Hatchling, hear me out. It is very straightforward.

Add hatchling configuration to `pyproject.toml`.

```toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.version]
source = "code"
path = "src/my_project/_version.py"
# expression = "__version__"  # default

[tool.hatch.build.hooks.custom]
path = "hatch_build.py"
```

Basically you are telling Hatchling to execute `src/my_project/_version.py` and use `__version__` as the version string.

Add `hatch_build.py` to the project root.

```python
import tempfile
import textwrap
from pathlib import Path
from typing import Any

import tomllib  # python >= 3.11
from hatchling.builders.hooks.plugin.interface import BuildHookInterface


class CustomBuildHook(BuildHookInterface):
    def initialize(self, version: str, build_data: dict[str, Any]) -> None:
        if version == "editable":
            return

        with open(Path(self.root) / "pyproject.toml", "rb") as f:
            pyproject_toml = tomllib.load(f)

        version_py = Path(
            pyproject_toml["tool"]["hatch"]["version"]["path"]
        ).read_text()
        exec(version_py, globals())  # __version_dict__ is defined here

        # replace the file with a constant version
        self.temp_version_file = tempfile.NamedTemporaryFile(mode="w", delete=True)  # noqa: SIM115
        self.temp_version_file.write(
            textwrap.dedent(f"""
                #!/usr/bin/env python3
                # This file is generated by version-pioneer
                # by evaluating the original _version.py file and storing the computed versions as a constant.

                __version_dict__ = {__version_dict__}
                __version__ = __version_dict__["version"]
                
                if __name__ == "__main__":
                    import json

                    print(json.dumps(__version_dict__))
            """)
        )
        self.temp_version_file.flush()

        build_data["force_include"][self.temp_version_file.name] = (
            "src/ml_project/_version.py"
        )

    def finalize(
        self,
        version: str,
        build_data: dict[str, Any],
        artifact_path: str,
    ) -> None:
        if version == "editable":
            return

        # Delete the temporary version file
        self.temp_version_file.close()
```

It just replaces the `_version.py` file with a constant version string. The version string is computed by evaluating the original `_version.py` file.
This is skipped when the project is installed in editable mode (`pip install -e .`).

Now you can install your package with `pip install .`, `pip install -e .`, or build a wheel with `hatch build` or `uv build`.

## ðŸš¦ Usage

