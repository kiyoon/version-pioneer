from __future__ import annotations

import json
import textwrap
from enum import Enum
from pathlib import Path


class ResolutionFormat(str, Enum):
    python = "python"
    json = "json"
    version_string = "version-string"


def get_version_py_code():
    """Get the content of _version.py file."""
    import json
    from importlib.metadata import Distribution

    from version_pioneer import __version__

    direct_url = Distribution.from_name("version-pioneer").read_text("direct_url.json")
    assert direct_url is not None
    pkg_is_editable = json.loads(direct_url).get("dir_info", {}).get("editable", False)

    # If the package is installed as editable, the _version.py file is resolved and replaced.
    # So we use another copy (copied during build) to print the original content.
    if pkg_is_editable:
        from version_pioneer._version import __file__ as version_py_file

        version_py_file = Path(version_py_file)
    else:
        from version_pioneer import __file__ as module_file

        version_py_file = Path(module_file).parent / "_version.py.orig"

    version_py_code = version_py_file.read_text()

    # Put header after the shebang line
    version_py_code = version_py_code.replace(
        "#!/usr/bin/env python3",
        textwrap.dedent(f"""
        #!/usr/bin/env python3
        # GENERATED BY version-pioneer-v{__version__}
        """).strip(),
        1,
    )

    return version_py_code


def exec_version_py(
    project_dir_or_version_py_file: Path | None = None,
    output_format: ResolutionFormat = ResolutionFormat.python,
):
    """
    Resolve the _version.py file for build, and print the content.

    Examples:
        $ version-pioneer resolve-version --output-format=json
        {"version": "1.2.3", "full_revisionid": "xxxxxx", "dirty": False, "error": None, "date": "2024-12-17T12:25:42+0900"}

        $ version-pioneer resolve-version --output-format=python
        #!/usr/bin/env python3
        # GENERATED BY version-pioneer-v0.1.0
        __version_dict__ = {
            "version": "0.3.2+15.g2127fd3.dirty",
            "full-revisionid": "2127fd373d14ed5ded497fc18ac1c1b667f93a7d",
            "dirty": True,
            "error": None,
            "date": "2024-12-17T12:25:42+0900",
        }
        __version__ = version_dict["version"]

        if __name__ == "__main__":
            import json

            print(json.dumps(__version_dict__))
    """
    from version_pioneer import __version__
    from version_pioneer.utils.exec_version_py import (
        exec_version_py_to_get_version_dict,
    )
    from version_pioneer.utils.toml import (
        find_pyproject_toml,
        get_toml_value,
        load_toml,
    )

    if project_dir_or_version_py_file is None:
        project_dir_or_version_py_file = Path.cwd()

    if project_dir_or_version_py_file.is_file():
        version_py_file = project_dir_or_version_py_file
    else:
        pyproject_toml_file = find_pyproject_toml(project_dir_or_version_py_file)
        pyproject_toml = load_toml(pyproject_toml_file)
        version_py_file = Path(
            get_toml_value(
                pyproject_toml, ["tool", "version-pioneer", "versionfile-source"]
            )
        )
        if not version_py_file.exists():
            version_py_file2 = Path(
                get_toml_value(
                    pyproject_toml, ["tool", "version-pioneer", "versionfile-build"]
                )
            )
            if not version_py_file2.exists():
                raise FileNotFoundError(
                    f"Version file not found: {version_py_file} or {version_py_file2}"
                )
            version_py_file = version_py_file2

    version_dict = exec_version_py_to_get_version_dict(version_py_file)
    if output_format == ResolutionFormat.python:
        return textwrap.dedent(
            f"""
                #!/usr/bin/env python3
                # GENERATED BY version-pioneer-v{__version__}
                # by evaluating the original _version.py file and storing the computed versions as a constant.

                __version_dict__ = {version_dict}
                __version__ = __version_dict__["version"]
                
                if __name__ == "__main__":
                    import json

                    print(json.dumps(__version_dict__))
                """
        ).strip()
    elif output_format == ResolutionFormat.json:
        return json.dumps(version_dict)
    elif output_format == ResolutionFormat.version_string:
        return version_dict["version"]
    else:
        raise ValueError(f"Invalid output format: {output_format}")
