from __future__ import annotations

import textwrap
from pathlib import Path

from version_pioneer import (
    VersionPioneerConfig,
    VersionStyle,
    get_version_dict,
)
from version_pioneer.utils.exec_version_py import (
    RESOLUTION_FORMAT_TYPE,
    ResolutionFormat,
    version_dict_to_str,
)


def get_version_py_code():
    """Get the content of _version.py file."""
    from version_pioneer import __version__, get_version_py_path

    version_py_code = get_version_py_path().read_text()

    # Put header after the shebang line
    version_py_code = version_py_code.replace(
        "#!/usr/bin/env python3",
        textwrap.dedent(f"""
            #!/usr/bin/env python3
            # GENERATED BY version-pioneer-{__version__}
        """).strip(),
        1,
    )

    return version_py_code


def exec_version_py(
    project_dir_or_version_py_file: Path | None = None,
    *,
    output_format: RESOLUTION_FORMAT_TYPE = ResolutionFormat.version_string,
):
    """
    Resolve the _version.py file for build, and print the content.

    Examples:
        $ version-pioneer resolve-version --output-format=json
        {"version": "1.2.3", "full_revisionid": "xxxxxx", "dirty": False, "error": None, "date": "2024-12-17T12:25:42+0900"}

        $ version-pioneer resolve-version --output-format=python
        #!/usr/bin/env python3
        # GENERATED BY version-pioneer-v0.1.0
        __version_dict__ = {
            "version": "0.3.2+15.g2127fd3.dirty",
            "full-revisionid": "2127fd373d14ed5ded497fc18ac1c1b667f93a7d",
            "dirty": True,
            "error": None,
            "date": "2024-12-17T12:25:42+0900",
        }
        __version__ = version_dict["version"]

        if __name__ == "__main__":
            import json

            print(json.dumps(__version_dict__))
    """
    from version_pioneer.utils.exec_version_py import (
        exec_version_py_to_get_version_dict,
        find_version_py_from_project_dir,
    )

    if project_dir_or_version_py_file is None:
        version_py_file = find_version_py_from_project_dir(Path.cwd())
    elif project_dir_or_version_py_file.is_file():
        version_py_file = project_dir_or_version_py_file
    else:
        version_py_file = find_version_py_from_project_dir(
            project_dir_or_version_py_file
        )

    version_dict = exec_version_py_to_get_version_dict(version_py_file)
    return version_dict_to_str(version_dict, output_format)


def get_version_builtin(
    project_dir: Path | None = None,
    *,
    style: VersionStyle = VersionStyle.pep440,
    tag_prefix: str = "v",
    parentdir_prefix: str | None = None,
    output_format: RESOLUTION_FORMAT_TYPE = ResolutionFormat.version_string,
):
    """
    WITHOUT using the _version.py file, get version with Version-Pioneer logic.

    Useful when you don't need to customise the _version.py file, and you work in non-Python projects
    so you don't care about re-evaluating the version file.

    Args:
        project_dir: The root or child directory of the project.
        parentdir_prefix: The prefix of the parent directory. (e.g. {github_repo_name}-)
    """
    cfg = VersionPioneerConfig(
        style=style,
        tag_prefix=tag_prefix,
        parentdir_prefix=parentdir_prefix,
    )

    version_dict = get_version_dict(
        cfg, cwd=Path.cwd() if project_dir is None else project_dir
    )
    return version_dict_to_str(version_dict, output_format)
