from __future__ import annotations

import textwrap
from pathlib import Path

from version_pioneer.utils.exec_version_py import (
    RESOLUTION_FORMAT_TYPE,
    ResolutionFormat,
    version_dict_to_str,
)
from version_pioneer.version_pioneer_core import (
    VersionPioneerConfig,
    VersionStyle,
    get_version_dict_from_vcs,
)


def get_version_script_core_code():
    """Get the content of version_pioneer_core.py file."""
    from version_pioneer import VERSION_PIONEER_CORE_FILE, __version__

    version_py_code = VERSION_PIONEER_CORE_FILE.read_text()

    # Put header after the shebang line
    version_py_code = version_py_code.replace(
        "#!/usr/bin/env python3",
        textwrap.dedent(f"""
            #!/usr/bin/env python3
            # GENERATED BY version-pioneer-{__version__}
        """).strip(),
        1,
    )

    return version_py_code


def exec_version_py(
    project_dir_or_version_py_file: Path | None = None,
    *,
    output_format: RESOLUTION_FORMAT_TYPE = ResolutionFormat.version_string,
):
    """
    Resolve the _version.py file for build, and print the content.

    Examples:
        $ version-pioneer resolve-version --output-format=json
        {"version": "1.2.3", "full_revisionid": "xxxxxx", "dirty": False, "error": None, "date": "2024-12-17T12:25:42+0900"}

        $ version-pioneer resolve-version --output-format=python
        #!/usr/bin/env python3
        # GENERATED BY version-pioneer-v0.1.0
        def get_version_dict():
            return {
                "version": "0.3.2+15.g2127fd3.dirty",
                "full-revisionid": "2127fd373d14ed5ded497fc18ac1c1b667f93a7d",
                "dirty": True,
                "error": None,
                "date": "2024-12-17T12:25:42+0900",
            }

        if __name__ == "__main__":
            import json

            print(json.dumps(get_version_dict()))
    """
    from version_pioneer.utils.exec_version_py import (
        exec_version_py_to_get_version_dict,
        find_version_script_from_project_dir,
    )

    if project_dir_or_version_py_file is None:
        version_py_file = find_version_script_from_project_dir(Path.cwd())
    elif project_dir_or_version_py_file.is_file():
        version_py_file = project_dir_or_version_py_file
    else:
        version_py_file = find_version_script_from_project_dir(
            project_dir_or_version_py_file
        )

    version_dict = exec_version_py_to_get_version_dict(version_py_file)
    return version_dict_to_str(version_dict, output_format)


def get_version(
    cwd: Path | None = None,
    *,
    style: VersionStyle = VersionStyle.pep440,
    tag_prefix: str = "v",
    parentdir_prefix: str | None = None,
    output_format: RESOLUTION_FORMAT_TYPE = ResolutionFormat.version_string,
):
    """
    WITHOUT using the installed _version.py file, get version with Version-Pioneer logic, and return as a string.

    Useful when you don't need to customise the _version.py file, and you work in non-Python projects
    so you don't care about re-evaluating the version file.

    Args:
        project_dir: The root or child directory of the project.
        parentdir_prefix: The prefix of the parent directory. (e.g. {github_repo_name}-)
    """
    cfg = VersionPioneerConfig(
        style=style,
        tag_prefix=tag_prefix,
        parentdir_prefix=parentdir_prefix,
    )

    version_dict = get_version_dict_from_vcs(
        cfg, cwd=Path.cwd() if cwd is None else cwd
    )
    return version_dict_to_str(version_dict, output_format)
