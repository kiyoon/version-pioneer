# Allow print
# Allow many arguments
# Allow relative import from parent
# Allow using Optional
# ruff: noqa: T201 PLR0913 TID252 FA100

# NOTE: type | None only works in Python 3.10+ with typer, so we use Optional instead.

try:
    import typer
except ModuleNotFoundError:
    print("⚠️ CLI dependencies are not installed.")
    print("Please install Version-Pioneer with `pip install 'version-pioneer[cli]'`.")
    print("or even better, `uv tool install version-pioneer[cli]`.")
    import sys

    sys.exit(1)


import json
import textwrap
from enum import Enum
from pathlib import Path
from typing import Optional

import rich
from rich.prompt import Prompt
from rich.syntax import Syntax

app = typer.Typer(
    no_args_is_help=True, context_settings={"help_option_names": ["-h", "--help"]}
)


def version_callback(*, value: bool):
    if value:
        from .. import __version__

        print(__version__)
        raise typer.Exit


@app.callback()
def common(
    ctx: typer.Context,
    *,
    version: bool = typer.Option(
        None, "-v", "--version", callback=version_callback, help="Show version"
    ),
):
    pass


@app.command()
def install(project_dir: Optional[Path] = None):
    """Install _version.py at `tool.version-pioneer.versionfile-source` in pyproject.toml."""


@app.command()
def print_version_py():
    """Print the content of _version.py file (for manual installation)."""
    import json
    from importlib.metadata import Distribution

    from version_pioneer import __version__

    direct_url = Distribution.from_name("version-pioneer").read_text("direct_url.json")
    assert direct_url is not None
    pkg_is_editable = json.loads(direct_url).get("dir_info", {}).get("editable", False)

    # If the package is installed as editable, the _version.py file is resolved and replaced.
    # So we use another copy (copied during build) to print the original content.
    if pkg_is_editable:
        from version_pioneer._version import __file__ as version_py_file

        version_py_file = Path(version_py_file)
    else:
        from version_pioneer import __file__ as module_file

        version_py_file = Path(module_file).parent / "_version.py.orig"

    version_py_code = version_py_file.read_text()

    # Put header after the shebang line
    version_py_code = version_py_code.replace(
        "#!/usr/bin/env python3",
        textwrap.dedent(f"""
        #!/usr/bin/env python3
        # GENERATED BY version-pioneer-v{__version__}
        """).strip(),
        1,
    )

    print(version_py_code)


class ResolutionFormat(str, Enum):
    python = "python"
    json = "json"
    version_string = "version-string"


@app.command()
def exec_version_py(
    project_dir_or_version_py_file: Optional[Path] = None,
    output_format: ResolutionFormat = ResolutionFormat.python,
):
    """
    Resolve the _version.py file for build, and print the content.

    Examples:
        $ version-pioneer resolve-version --output-format=json
        {"version": "1.2.3", "full_revisionid": "xxxxxx", "dirty": False, "error": None, "date": "2024-12-17T12:25:42+0900"}

        $ version-pioneer resolve-version --output-format=python
        #!/usr/bin/env python3
        # GENERATED BY version-pioneer-v0.1.0
        __version_dict__ = {
            "version": "0.3.2+15.g2127fd3.dirty",
            "full-revisionid": "2127fd373d14ed5ded497fc18ac1c1b667f93a7d",
            "dirty": True,
            "error": None,
            "date": "2024-12-17T12:25:42+0900",
        }
        __version__ = version_dict["version"]

        if __name__ == "__main__":
            import json

            print(json.dumps(__version_dict__))
    """
    from version_pioneer import __version__
    from version_pioneer.utils.exec_version_py import (
        exec_version_py_to_get_version_dict,
    )
    from version_pioneer.utils.toml import (
        find_pyproject_toml,
        get_toml_value,
        load_toml,
    )

    if project_dir_or_version_py_file is None:
        project_dir_or_version_py_file = Path.cwd()

    if project_dir_or_version_py_file.is_file():
        version_py_file = project_dir_or_version_py_file
    else:
        pyproject_toml_file = find_pyproject_toml(project_dir_or_version_py_file)
        pyproject_toml = load_toml(pyproject_toml_file)
        version_py_file = Path(
            get_toml_value(
                pyproject_toml, ["tool", "version-pioneer", "versionfile-source"]
            )
        )
        if not version_py_file.exists():
            version_py_file2 = Path(
                get_toml_value(
                    pyproject_toml, ["tool", "version-pioneer", "versionfile-build"]
                )
            )
            if not version_py_file2.exists():
                raise FileNotFoundError(
                    f"Version file not found: {version_py_file} or {version_py_file2}"
                )
            version_py_file = version_py_file2

    version_dict = exec_version_py_to_get_version_dict(version_py_file)
    if output_format == ResolutionFormat.python:
        print(
            textwrap.dedent(
                f"""
                #!/usr/bin/env python3
                # GENERATED BY version-pioneer-v{__version__}
                # by evaluating the original _version.py file and storing the computed versions as a constant.

                __version_dict__ = {version_dict}
                __version__ = __version_dict__["version"]
                
                if __name__ == "__main__":
                    import json

                    print(json.dumps(__version_dict__))
                """
            ).strip()
        )
    elif output_format == ResolutionFormat.json:
        print(json.dumps(version_dict))
    elif output_format == ResolutionFormat.version_string:
        print(version_dict["version"])
    else:
        raise ValueError(f"Invalid output format: {output_format}")


@app.command()
def config(config_dir: Optional[Path] = None):
    """
    Copy the template .env file to the config directory.
    """
    from dotenv import dotenv_values, set_key
    from ml_project import APP_NAME, PROJECT_DIR
    from ml_project import __file__ as package_root_file
    from platformdirs import user_config_path

    template_file = Path(package_root_file).parent / "template.env"
    template_envs = dotenv_values(template_file, interpolate=False)

    template_env_text = template_file.read_text().strip()
    rich.print()
    rich.print(":scroll: Default configuration is as follows:")
    rich.print(
        Syntax(template_env_text, "shell", line_numbers=True, theme="solarized-dark")
    )

    if config_dir is None:
        if PROJECT_DIR is None:
            # if installed properly without -e flag, use the default config directory.
            config_dir = user_config_path(APP_NAME)
        else:
            # if installed as a development package with pip install -e,
            # ask the user to choose which config directory to use.
            user_config_dir = user_config_path(APP_NAME)
            rich.print()
            rich.print("Choose where to store the configuration file:")
            rich.print(f"[bold]1.[/bold] {PROJECT_DIR}/.env -> easy development")
            rich.print(f"[bold]2.[/bold] {user_config_dir}/.env -> production")
            rich.print()
            choice = Prompt.ask("Enter choice", choices=["1", "2"], default="1")
            if choice == "1":
                config_dir = PROJECT_DIR
            else:
                config_dir = user_config_dir

    config_dir = config_dir.resolve()
    config_dir.mkdir(parents=True, exist_ok=True)

    dotenv_file = config_dir / ".env"
    if dotenv_file.exists():
        rich.print()
        rich.print(":scroll: Your current configuration is as follows:")
        rich.print(
            Syntax(
                dotenv_file.read_text().strip(),
                "shell",
                line_numbers=True,
                theme="solarized-dark",
            )
        )

        # Use the existing dotenv file as the base
        # But if there are new variables in the custom file, ignore them.
        current_envs = dotenv_values(dotenv_file, interpolate=False)
        for key in current_envs:
            if key not in template_envs:
                current_envs.pop(key)
        template_envs.update(current_envs)

        # rich.print()
        # confirm = Confirm.ask(
        #     f"File [green]{dotenv_file}[/green] already exists. [red]Overwrite?[/red]",
        #     default=False,
        # )
        # if not confirm:
        #     rich.print("[red]Aborted.[/red]")
        #     sys.exit(1)
    else:
        # First create as the template, because it may have some useful comments and structure.
        dotenv_file.write_text(template_env_text)

    # Then update each variables
    rich.print()
    rich.print("Type in the values for the following variables:")
    for i, (key, value) in enumerate(template_envs.items()):
        choice = Prompt.ask(f"{i+1}/{len(template_envs)}. {key}", default=value)
        if choice is None:
            set_key(dotenv_file, key, "", quote_mode="auto")
        else:
            set_key(dotenv_file, key, choice, quote_mode="auto")

    rich.print()
    rich.print(":scroll: Updated configuration is as follows:")
    rich.print(
        Syntax(
            dotenv_file.read_text().strip(),
            "shell",
            line_numbers=True,
            theme="solarized-dark",
        )
    )
    rich.print()
    rich.print(f"Configuration file created at: '{dotenv_file}'")


def main():
    app()


if __name__ == "__main__":
    main()
